{"version":3,"file":"index.cjs.js","sources":["../../src/registerFunction.ts"],"sourcesContent":["const root = globalThis as any;\n\nimport { HandleParams, HandleReturnType } from \"./types/function-types\";\nexport type * from \"./types/function-types\";\n\nexport interface CustomFunctionMeta<F extends (...args: any[]) => any> {\n  /**\n   * The javascript name of the function. Notice it must be unique across all\n   * other functions and function namespaces. If two functions have the same\n   * name, they should be registered with different `meta.namespace`.\n   */\n  name: string;\n  /**\n   * A namespace for organizing groups of functions. It's also used to handle\n   * function name collisions. If a function has a namespace, it will be used\n   * whenever accessing the function.\n   */\n  namespace?: string;\n  /**\n   * A display name for the function. It will be shown only in studio.\n   */\n  displayName?: string;\n  /**\n   * Documentation for the registered function.\n   */\n  description?: string;\n  /**\n   * An array containing the list of parameters names the function takes.\n   * Optionally they can also be registered with the expected param types.\n   */\n  params?: HandleParams<Parameters<F>>;\n  /**\n   * Return value information.\n   */\n  returnValue?: {\n    /**\n     * The function return type.\n     */\n    type?: HandleReturnType<Parameters<F>, ReturnType<F>>;\n    /**\n     * The function return value description.\n     */\n    description?: string;\n  };\n  /**\n   * Typescript function declaration. If specified, it ignores the types\n   * provided by `params` and `returnValue`.\n   */\n  typescriptDeclaration?: string;\n\n  /**\n   * Whether this function can be used as a query in the editor.\n   */\n  isQuery?: boolean;\n  /**\n   * The path to be used when importing the function in the generated code.\n   * It can be the name of the package that contains the function, or the path\n   * to the file in the project (relative to the root directory).\n   */\n  importPath: string;\n  /**\n   * Whether the function is the default export from that path. Optional: if\n   * not specified, it's considered `false`.\n   */\n  isDefaultExport?: boolean;\n\n  /**\n   * A function that takes the function arguments and returns a data key\n   * and a fetcher function.\n   * The data key is used to cache the result of the fetcher, and should only\n   * include the arguments that are used to fetch the data.\n   * The result of the fetcher will be used as the context of the function\n   * in studio and should return a promise.\n   */\n  fnContext?: (...args: Partial<Parameters<F>>) => {\n    dataKey: string;\n    fetcher: () => Promise<any>;\n  };\n}\n\nexport interface CustomFunctionRegistration {\n  function: (...args: any[]) => any;\n  meta: CustomFunctionMeta<any>;\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicFunctionsRegistry: CustomFunctionRegistration[];\n  }\n}\n\nif (root.__PlasmicFunctionsRegistry == null) {\n  root.__PlasmicFunctionsRegistry = [];\n}\n\nexport default function registerFunction<F extends (...args: any[]) => any>(\n  fn: F,\n  meta: CustomFunctionMeta<F>\n) {\n  // Check for duplicates\n  if (\n    root.__PlasmicFunctionsRegistry.some(\n      (r: CustomFunctionRegistration) =>\n        r.function === fn &&\n        r.meta.name === meta.name &&\n        r.meta.namespace == meta.namespace\n    )\n  ) {\n    return;\n  }\n  root.__PlasmicFunctionsRegistry.push({ function: fn, meta });\n}\n"],"names":[],"mappings":";;;;;AAAA,IAAM,IAAI,GAAG,UAAiB,CAAC;AA2F/B,IAAI,IAAI,CAAC,0BAA0B,IAAI,IAAI,EAAE;AAC3C,IAAA,IAAI,CAAC,0BAA0B,GAAG,EAAE,CAAC;AACtC,CAAA;AAEa,SAAU,gBAAgB,CACtC,EAAK,EACL,IAA2B,EAAA;;AAG3B,IAAA,IACE,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAClC,UAAC,CAA6B,EAAA;AAC5B,QAAA,OAAA,CAAC,CAAC,QAAQ,KAAK,EAAE;AACjB,YAAA,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI;AACzB,YAAA,CAAC,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,CAAA;AAFlC,KAEkC,CACrC,EACD;QACA,OAAO;AACR,KAAA;AACD,IAAA,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,IAAI,EAAA,IAAA,EAAE,CAAC,CAAC;AAC/D;;;;"}